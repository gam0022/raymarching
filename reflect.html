<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Steel Frame</title>
  </head>
  <body>
    <script id="fragment_shader" type="x-shader/x-fragment">
    precision highp float;
    uniform float time;
    uniform vec2 mouse;
    uniform vec2 resolution;
    
    const float EPS = 0.001;
    const float PADDING = EPS * 100.0;
    
    // distance functions
    vec2 onRep(vec2 p, float interval) {
      return mod(p, interval) - interval * 0.5;
    }
    
    float distBar(vec2 p, float interval, float width) {
      return length(max(abs(onRep(p, interval)) - width, 0.0));
    }
    
    float distTube(vec2 p, float interval, float width) {
      return length(onRep(p, interval)) - width;
    }

    float distSphere(vec3 p, vec3 c, float r) {
      return length(c - p) - r;
    }

    float distFloor(vec3 p){
      return dot(p, vec3(0.0, 1.0, 0.0)) + 1.0;
    }

    vec4 minVec4(vec4 a, vec4 b) {
      return (a.a < b.a) ? a : b;
    }
    
    float distScene(vec3 p) {
      return min(
        distSphere(p, vec3(0, 0, 0), 1.0), 
        distFloor(p)
      );
    }

    float checkeredPattern(vec3 p) {
      float u = 1.0 - floor(mod(p.x, 2.0));
      float v = 1.0 - floor(mod(p.z, 2.0));
      if((u == 1.0 && v < 1.0) || (u < 1.0 && v == 1.0)){
        return 0.2;
      } else {
        return 1.0;
      }
    }

    vec4 colorScene(vec3 p) {
      return minVec4(
        vec4(1.0, 0.1, 0.1, distSphere(p, vec3(0, 0, 0), 1.0)), 
        vec4(vec3(0.5) * checkeredPattern(p), distFloor(p))
      );
    }
    
    vec3 getNormal(vec3 p) {
      return normalize(vec3(
        distScene(p + vec3(  EPS, 0.0, 0.0)) - distScene(p + vec3( -EPS, 0.0, 0.0)),
        distScene(p + vec3(0.0,   EPS, 0.0)) - distScene(p + vec3(0.0,  -EPS, 0.0)),
        distScene(p + vec3(0.0, 0.0,   EPS)) - distScene(p + vec3(0.0, 0.0,  -EPS))
      ));
    }

    float getShadow(vec3 ro, vec3 rd){
      float h = 0.0;
      float c = 0.0;
      float r = 1.0;
      float shadowCoef = 0.5;
      for(float t = 0.0; t < 50.0; t++){
        h = distScene(ro + rd * c);
        if(h < 0.001){
          return shadowCoef;
        }
        r = min(r, h * 16.0 / c);
        c += h;
      }
      return 1.0 - shadowCoef + r * shadowCoef;
    }
    
    void main(void) {
      // fragment position
      vec2 p = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y);
    
      // camera and ray
      vec3 cPos  = vec3(0.0, 1.6, -2.0);
      vec3 cDir  = normalize(vec3(0.0, -0.9, 1.0));
      vec3 cUp   = cross(cDir, vec3(1.0, 0.0 ,0.0));
      vec3 cSide = cross(cDir, cUp);
      float targetDepth = 1.3;
      vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir * targetDepth);
    
      // direction light
      vec3 lightDir = normalize(vec3(-3, 5, -2));
    
      // marching loop
      float dist;
      float depth = 0.0;
      vec3 dPos = cPos;
      for(int i = 0; i < 64; i++){
        dist = distScene(dPos);
        depth += dist;
        dPos = cPos + depth * ray;
        if (abs(dist) < EPS) break;
      }
    
      // hit check
      vec3 color;
      float shadow = 1.0;
      if (abs(dist) < EPS) {
        vec3 normal = getNormal(dPos);
        float diffuse = clamp(dot(lightDir, normal), 0.1, 1.0);
        color = colorScene(dPos).rgb * diffuse;
        shadow = getShadow(dPos + normal * PADDING, lightDir);
      } else {
        color = vec3(0.2);
      }
      gl_FragColor = vec4(color * max(0.5, shadow) + 0.05 * depth, 1.0);
    }
    </script>
    
    <script id="vertex_shader" type="x-shader/x-vertex">
    void main(void) {
      gl_Position = vec4(position, 1.0);
    }
    </script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r73/three.min.js" type="text/javascript"></script>
    <script src="script.js" type="text/javascript"></script>
    <div><input type="button" value="save image" onclick="saveImage();"></div>
  </body>
</html>
